########################## General Imports #####################################
import os
import re
import sys
import time
import subprocess
import mmap
import contextlib
from xml.etree import  ElementTree
import xml.etree.ElementTree as ET                                              # importing Xml parsing module to extract the text from the xml

########################## Local Imports #######################################
import lib_constants
import lib_epcs
import json
import re
import utils
import library
import lib_tool_installation
################################################################################
#   Function name   : verify_acpi_table()
#   description     : This function will check if the desired table is present
#                     in the Systemscope log .
#   parameters      : 'test_case_id' is test case id
#                     'script_id' is script id
#                     'token ' is original string
#   Returns         : True/False/Log path of ACPI dump
######################### Main script ##########################################
def verify_acpi_table(table_type,test_case_id,script_id,log_level = "ALL",
                      tbd=None):
    logfile = script_id.split(".")[0]
    log_path = lib_constants.SCRIPTDIR                                          #Log to be generated in the current script directory
    output = []                                                                 #Initilaized List to store table names
    os.chdir(log_path)
    for files in os.listdir(os.path.join(log_path)):
        if 'acpi' in files.lower() and files.endswith(".txt"):
            os.remove(files)                                                    #Remove any existing logs
    try:
        systemscopepath = lib_constants.SYSCOPE_TOOLDIR                         #reading the config file to fetch the details of Systemscope tool

        if lib_tool_installation.install_Syscope(test_case_id,script_id,
                                                 log_level,tbd):
            library.write_log(lib_constants.LOG_INFO,"INFO :SystemScope"
                    "is Installed.", test_case_id,script_id,"SystemScope","None",
                              log_level, tbd)                                   #Check if system scope is installed otherwise install the tool
        else:
            library.write_log(lib_constants.LOG_INFO,
            "INFO : SystemScope is NOT installed, Installing Now",test_case_id,
                              script_id,"system scope","None",log_level, tbd)
    except Exception as e:
        library.write_log(lib_constants.LOG_ERROR,"ERROR: In Installation : "+str(e),
                          test_case_id,script_id,"system scope","None",
                          log_level, tbd)
        return False

    try:
        if lib_tool_installation.execute_syscope_New(test_case_id,script_id,
                                                     log_level,tbd):			#Executes the syscope tool command line and saves the log in the tool folder
            library.write_log(lib_constants.LOG_INFO,
            "INFO: Log has been generated By System Scope tool",test_case_id,
                              script_id,"SystemScope","None",log_level,tbd)
        else:
            library.write_log(lib_constants.LOG_INFO,
            "INFO: Log has not been generated By System Scope tool",
                         test_case_id, script_id, "system scope","None",
                                                    log_level, tbd)
            return False

    except Exception as e:
        library.write_log(lib_constants.LOG_ERROR,"ERROR: In generating log : "+str(e),
                          test_case_id,script_id,"system scope","None",
                          log_level,tbd)
        return False
    try:
        with open(systemscopepath + os.sep + 'syscope.xml', 'rt') \
                as xmlfile:                                                     #open the system scope xml file
            tree = ElementTree.parse(xmlfile)                                   #get tree element
            sys_scope_root = tree.getroot()                                     #get root element
        for node in tree.iter('Module'):                                        #loop through the Module tags
            name = node.attrib.get('Name')                                      #get all the name mode values
            output.append(str(name))                                            #appending to output list
        if 'ACPI'in output:                                                     #Checking if ACPI tables enumerated in log
            child_root = sys_scope_root.findall(".//*[@Name='ACPI']/Group")     #Find all the group tags values
            acpi_subtable_list=[]
            for item in child_root:
                all_table_in_acpi = item.attrib                                 #get all the attribute of the tables
                for key,value in list(all_table_in_acpi.items()):                     #loop though each table attribute and store the value in list
                    acpi_subtable_list.append(str(value))
        else:
            library.write_log(lib_constants.LOG_INFO,"INFO: ACPI table does not"
                "exist in generated log file xml file",test_case_id,script_id,
                              "system scope","None",log_level,tbd)              #Return if ACPI tables doesn't exists
            return False
    except Exception as e:
        library.write_log(lib_constants.LOG_ERROR,"ERROR: In opening log: "+str(e),
                test_case_id,script_id,"system scope","None",log_level,tbd)
        return False

    acpi_search_element = table_type.strip().upper()
    if not table_type.upper() == 'NONE':
        if acpi_search_element in acpi_subtable_list:                           #checking for child table name under ACPI
            try:
                os.chdir(systemscopepath)
                acpi_table_path = log_path+r"\\"+logfile+"_acpi_table.txt"
                if os.path.exists(acpi_table_path):
                    os.remove(acpi_table_path)                                  #checks if older log file exists then removes the older logs
                tree = ET.parse(systemscopepath + os.sep + 'syscope.xml')
                getroot = tree.getroot()                                        #get root node of the xml tree
                acpi_content = getroot.findall(".//*[@Na"
                        "me='"+acpi_search_element+"']/Item")                   #search for the table name and get all the items of the table
                for expectedtable in acpi_content:                              #loop through matching table elements content
                    table_content = expectedtable.attrib                        #find the attribute of the content
                    for key,value in list(table_content.items()):                     #iterate through each of the attribute items
                        try:
                            with open(acpi_table_path,"a+") as acpi_table:      #opens the file and writes the value of table content
                                acpi_table.write(value+"\n")
                        except Exception as e:
                           library.write_log(lib_constants.LOG_ERROR,
                                        "ERROR: In creating Dump : "+str(e),
                                        test_case_id,script_id,"None","None",
                                        log_level,tbd)
                           return False
                    acpi_table.close()
                return acpi_table_path                                          #Return the Table dump created from Systemscope log
            except Exception as e:
                library.write_log(lib_constants.LOG_ERROR,
                                  "ERROR: In parsing log:  "+str(e),
                                  test_case_id,script_id,log_level,tbd)
                return False
        else:
            return False
    else:                                                                       #child table name does not exist then start creating dump of all the table in ACPI branch
        try:
            acpi_dump_path = log_path+r"\\"+logfile+"_acpi_dump.txt"
            if os.path.exists(acpi_dump_path):
                os.remove(acpi_dump_path)                                       #checks if older log file exists then removes the older logs
            for each_table in acpi_subtable_list:
                content = sys_scope_root.findall(".//*[@Na"
                "me='"+each_table+"']/Item")
                for expectedtable in content:
                    table_content = expectedtable.attrib
                    for key,value in list(table_content.items()):
                        try:
                            with open(acpi_dump_path,"a+") as acpi_dump:        #opens the file and writes the table content
                                acpi_dump.write(value+"\n")
                        except Exception as e:
                            library.write_log(lib_constants.LOG_ERROR, "ERROR :"
                                +str(e),test_case_id,script_id,"None","None",
                                              log_level,tbd)
                            return False
                acpi_dump.close()

            return acpi_dump_path                                               #return all the acpi table combine.
        except Exception as e:
            library.write_log(lib_constants.LOG_ERROR,"ERROR: "+str(e),
                          test_case_id,script_id,"None","None",log_level,tbd)
            return False

################################################################################
#   Function name   : search_acpi_table()
#   description     : Search any specific data from the ACPI table
#   parameters      : 'test_case_id' is test case id
#                          'script_id' is script id
#                          'token ' is original string
#   Returns         : True/False/Search data
######################### Main script ##########################################

def search_acpi_table(sel,table_type,test_case_id,script_id,log_level = "ALL",
                      tbd = None):
    logfile =script_id.split(".")[0]
    log_path =lib_constants.SCRIPTDIR
    try:
        if "config-" in sel.lower():
            sel_tag=sel.split("-")[1]
            sel_var=sel.split("-")[2]
            sel=utils.ReadConfig(sel_tag, sel_var)
        Flag = False
        acpi_table_path = log_path+r"\\"+logfile+"_acpi_table.txt"
        acpi_dump_path = log_path+r"\\"+logfile+"_acpi_dump.txt"
        sel = sel.upper()
        if '"' in sel:
            sel = sel.strip('"')
        if os.path.exists(acpi_table_path):                                     #check if the text file exists in path
            if "UNDER" in sel.upper():
                search_id = sel.split("UNDER")[1].strip()
                search_ele = sel.split("UNDER")[0].strip()
                with open(acpi_table_path, 'r') as fsearch:                     #open the existing text file and create a virtual memory
                    for line in fsearch:
                        if search_id in line.upper():
                            if "_CID" == search_id or "_HID" == search_id:
                                if search_id in line.upper() and \
                                                search_ele in line.upper():
                                    return search_ele
                                else:
                                    pass
                        elif search_id.upper() == "ODVP METHOD" and \
                                "Method (ODVP" in line.strip():
                            while True:
                                search_line = next(fsearch)
                                if ":" in search_ele:
                                    search_ele = search_ele.replace(":", "=")
                                else:
                                    pass
                                if search_ele in search_line.upper():
                                    return search_ele
                                else:
                                    pass
                        else:
                            pass
                return False
            # if not '"' in sel:
            #     Flag = True
            #     Search_result = ""
            #
            #     '''pattern_first = re.compile(r'(\.\W+)?([^.]?' + sel + '[^.]*?\" )|' #regular expression pattern for search variable from text file
            #                            r'(\.\W+)?([^.]?' + sel + '[^.]*?\ ")|'
            #                            r'(\.\W+)?([^.]?' + sel + '[^.]*?\.)',
            #                    re.DOTALL | re.IGNORECASE | re.MULTILINE)'''
            #
            #     with open(acpi_table_path, 'r') as fsearch:                     #open the existing text file and create a virtual memory
            #         for line in fsearch:
            #             if sel.lower() in line.lower():
            #                 Search_result = line
            #                 print line
            #             else:
            #                 pass
            #     if len(Search_result) != 0:
            #         if '"' in Search_result:
            #             Search_result = Search_result.replace('"','')
            #         if ':' in Search_result:
            #             print Search_result
            #             Search_result = Search_result.split(':')[-1].strip().split(" ")[0]
            #         return Search_result
            #     else:
            #         return False
            # elif '"' in sel:
            #     sel = sel.strip('"')
            #     Flag = False
            #     with open(acpi_table_path,"r") as fp:
            #         for line in fp:
            #             if sel.lower() in line.lower():
            #                 Search_result = line
            #                 Flag = True
            #                 break
            #     if len(Search_result) == 0:
            #         return False
            #     else:
            #         return Search_result
            #
            # else:
            #     with open(acpi_table_path,"r") as fp:
            #         for line in fp:
            #             if sel.lower() in line.lower():
            #                 Search_result = line
            #                 if Flag is True:
            #                     if ':' in Search_result:
            #                         Search_result = Search_result.split(':')[-1]
            #                         if '"' in Search_result:
            #                             Search_result = Search_result.split('"')[1]
            #                         return Search_result
            #                     elif len(Search_result) != 0:
            #                         return True
            #                 else:
            #                     if len(Search_result) != 0:
            #                         return True
            #                     else:
            #                         return False
            with open(acpi_table_path, "r") as fp:
                for line in fp:
                    while "  " in line:
                        line = line.replace('  ',' ')
                    if sel.lower() in line.lower():
                        Flag = True
                        Search_result = line
                        if Flag is True:
                            if ':' in Search_result:
                                Search_result = Search_result.split(':')[-1]
                                if '"' in Search_result:
                                    Search_result = Search_result.split('"')[0]
                                return Search_result
                            elif len(Search_result) != 0:
                                return True
                        else:
                            if len(Search_result) != 0:
                                return True
                            else:
                                return False
                else:
                    return False

        if os.path.exists(acpi_dump_path):                                      #check if the text file exists in path
            if "UNDER" in sel.upper():
                search_id = sel.split("UNDER")[1].strip().replace('"','')
                search_ele = sel.split("UNDER")[0].strip().replace('"','')
                with open(acpi_dump_path, 'r') as fsearch:                      #open the existing text file
                    fsearch = fsearch.readlines()
                for line in range(len(fsearch)):
                    if search_id in fsearch[line].upper():
                        if "FIELD" in search_id:
                            if '{ "' in fsearch[line+1]:
                                while ('} "' not in fsearch[line]):
                                    if search_ele in  fsearch[line]:
                                        return search_ele
                                    else:
                                        continue
                                    line = line +1
                            else:
                                continue
                        else:
                            continue
                    else:
                        continue
                return False
            if sel.upper() == '(CPC2, PACKAGE (0X15)':
                Flag3 = False
                with open(acpi_dump_path,"r") as fp:
                    for line in fp:
                        if sel.upper() in line.upper():
                            break
                    for line in fp:
                        if '0X15' in line.upper():
                            break
                    for line in fp:
                        Search_result = line
                        Flag3 = True
                        break
                if Flag3 == True:
                    return Search_result
                else:
                    return False
            else:
                Flag2 = False
                with open(acpi_dump_path,"r") as fp:
                    for line in fp:
                        if sel.upper() in line.upper():
                            Flag2=True
                            Search_result = line
                            if len(Search_result) != 0:
                                return acpi_dump_path
                            else:
                                return False

                if Flag2 == False:
                    return False

    except Exception as e:                                                  #throw exception if any error occur
        library.write_log(lib_constants.LOG_ERROR,"ERROR: "+str(e),
                          test_case_id,script_id,"None","None",log_level,tbd)
        return False


################################################################################
#   Function name   : method_search_acpi_table()
#   description     : Search any specific data from the ACPI table
#   parameters      : 'test_case_id' is test case id
#                          'script_id' is script id
#                          'token ' is original string
#   Returns         : True/False/Search data
######################### Main script ##########################################


def method_search_acpi_table(method_name, device_name, test_case_id, script_id,
                             log_level, tbd):
    logfile = script_id.split(".")[0]
    log_path = lib_constants.SCRIPTDIR

    try:
        method_logList = []
        acpi_dump_path = log_path+r"\\"+logfile+"_acpi_dump.txt"
        a = 'device (' + device_name + ')'
        b = 'method (' + method_name
        if os.path.exists(acpi_dump_path):                                     #check if the text file exists in path
            with open(acpi_dump_path,'r') as fp:
                for line in fp:
                    if a in line.lower():
                        break
                for line in fp:
                    if b in line.lower():
                        break
                for line in fp:
                    method_logList.append(line)
                    if 'return' in line.lower():
                        break

        method_log = log_path + r'\\'+logfile+'_method_log.txt'
        fp = open(method_log, 'w')
        fp.writelines(method_logList)
        fp.close()
        if method_logList != o:
            return method_log
        else:
            return acpi_dump_path

    except Exception as e:                                                  #throw exception if any error occur
        library.write_log(lib_constants.LOG_ERROR, "ERROR: "+str(e),
                          test_case_id, script_id, "None", "None", log_level,
                          tbd)
        return False

